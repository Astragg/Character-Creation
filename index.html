<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NETRUNNER: BREACH RACE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-green: #00ff41;
            --neon-red: #ff0055;
            --dark-bg: #050505;
            --grid-color: #003b00;
        }
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--dark-bg);
            color: var(--neon-green);
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* CRT Effects */
        .scanline {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }
        .glow { text-shadow: 0 0 5px var(--neon-green); }
        .glow-red { text-shadow: 0 0 5px var(--neon-red); color: var(--neon-red); }
        
        /* Glitch Animation */
        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }
        .glitch-hover:hover { animation: glitch 0.2s infinite; }

        /* Grid Mechanics */
        .hex-cell {
            transition: all 0.1s;
            cursor: pointer;
        }
        .hex-cell:active { transform: scale(0.95); }
        .hex-cell.disabled { 
            opacity: 0.2; 
            pointer-events: none; 
            filter: grayscale(1);
        }
        .hex-cell.active-axis {
            background-color: rgba(0, 255, 65, 0.1);
            box-shadow: inset 0 0 10px var(--neon-green);
        }
        .hex-cell.selected {
            background-color: var(--neon-green);
            color: black;
            box-shadow: 0 0 15px var(--neon-green);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #001100; }
        ::-webkit-scrollbar-thumb { background: var(--neon-green); }

        /* Utility */
        .crt-flicker { animation: flicker 0.15s infinite; opacity: 0.9; }
        @keyframes flicker { 0% { opacity: 0.9; } 50% { opacity: 0.8; } 100% { opacity: 0.9; } }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative">

    <div class="scanline"></div>

    <!-- BACKGROUND DECO -->
    <div class="absolute top-0 left-0 p-2 text-xs opacity-30 leading-tight pointer-events-none">
        SYSTEM.ROOT<br>CONN_ESTABLISHED<br>ENCRYPTION: 2048-BIT
    </div>

    <!-- APP CONTAINER -->
    <div id="app" class="relative z-10 w-full h-full flex flex-col">
        
        <!-- 1. LOGIN TERMINAL -->
        <div id="view-login" class="absolute inset-0 flex flex-col items-center justify-center bg-black z-50">
            <div class="border border-[var(--neon-green)] p-8 max-w-md w-full bg-black shadow-[0_0_20px_rgba(0,255,65,0.2)]">
                <h1 class="text-4xl mb-2 glitch-hover cursor-default">NET_RUNNER_V.2.0</h1>
                <div class="h-px w-full bg-[var(--neon-green)] mb-6"></div>
                
                <div class="text-sm mb-2 opacity-70">> IDENTIFY_YOURSELF</div>
                <input type="text" id="username-input" maxlength="8" placeholder="ALIAS" 
                       class="w-full bg-[#001100] border border-[var(--neon-green)] text-[var(--neon-green)] p-4 text-xl outline-none focus:shadow-[0_0_10px_var(--neon-green)] uppercase placeholder-green-900 font-bold mb-6">
                
                <button id="btn-enter" class="w-full bg-[var(--neon-green)] text-black font-bold py-4 hover:bg-white transition-colors text-xl">
                    > INITIATE_LINK
                </button>
                <div id="auth-status" class="mt-2 text-xs animate-pulse">Est. Connection...</div>
            </div>
        </div>

        <!-- 2. LOBBY (NODE LIST) -->
        <div id="view-lobby" class="absolute inset-0 bg-black hidden flex flex-col">
            <header class="p-4 border-b border-green-900 flex justify-between items-center bg-[#001100]">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-[var(--neon-green)] rounded-full animate-pulse"></div>
                    <span class="text-xl">LOCAL_NET</span>
                </div>
                <div class="text-right text-sm">
                    <div id="lobby-user" class="opacity-80">GUEST</div>
                    <div id="lobby-id" class="text-[10px] opacity-50">ID: NULL</div>
                </div>
            </header>

            <div class="flex-1 p-4 overflow-hidden flex flex-col">
                <div class="flex justify-between items-end mb-2 border-b border-green-900/50 pb-2">
                    <h2 class="text-lg glow">AVAILABLE_NODES</h2>
                    <button id="btn-refresh" class="text-xs underline hover:text-white">[REFRESH_SCAN]</button>
                </div>

                <div id="game-list" class="flex-1 overflow-y-auto space-y-2 pr-2">
                    <!-- Game Items -->
                </div>
            </div>

            <div class="p-4 border-t border-green-900">
                <button id="btn-create" class="w-full border border-[var(--neon-green)] text-[var(--neon-green)] py-4 hover:bg-[var(--neon-green)] hover:text-black transition-all font-bold text-lg shadow-[0_0_15px_rgba(0,255,65,0.1)]">
                    > CREATE_NEW_NODE
                </button>
            </div>
        </div>

        <!-- 3. WAITING (HANDSHAKE) -->
        <div id="view-waiting" class="absolute inset-0 bg-black hidden flex flex-col items-center justify-center">
            <div class="text-center w-full max-w-md p-6 border-y border-green-900">
                <h2 class="text-2xl mb-4 animate-pulse">AWAITING_CLIENT_HANDSHAKE</h2>
                <div class="text-6xl mb-6 opacity-50">‚è≥</div>
                <div class="bg-[#001100] p-4 mb-6 border border-green-800 font-mono">
                    <div class="text-[10px] opacity-50 mb-1">ACCESS_KEY</div>
                    <div id="waiting-code" class="text-xl select-all">LOADING</div>
                </div>
                <button id="btn-cancel" class="text-red-500 hover:text-red-400 text-sm border border-red-900 px-6 py-2 hover:bg-red-900/20">
                    [ABORT_SESSION]
                </button>
            </div>
        </div>

        <!-- 4. GAME INTERFACE (BREACH) -->
        <div id="view-game" class="absolute inset-0 bg-black hidden flex flex-col">
            
            <!-- HUD -->
            <div class="flex justify-between items-start p-2 bg-[#001100] border-b border-green-800 h-24">
                <!-- My Score -->
                <div class="flex flex-col w-1/3">
                    <span class="text-[10px] opacity-70">USER_UPLOAD</span>
                    <div class="flex gap-1 mt-1" id="hud-my-score">
                        <!-- Pips -->
                    </div>
                </div>
                
                <!-- Round/Timer -->
                <div class="flex flex-col items-center w-1/3">
                    <div class="text-2xl font-bold text-white" id="hud-round">R:01</div>
                    <div id="game-status-msg" class="text-[10px] text-[var(--neon-red)] animate-pulse">LOCKED</div>
                </div>

                <!-- Enemy Score -->
                <div class="flex flex-col items-center w-1/3 items-end text-right">
                    <span class="text-[10px] opacity-70 text-[var(--neon-red)]">RIVAL_UPLOAD</span>
                    <div class="flex gap-1 mt-1 justify-end" id="hud-enemy-score">
                        <!-- Pips -->
                    </div>
                </div>
            </div>

            <!-- TARGET SEQUENCE -->
            <div class="p-2 flex flex-col items-center justify-center bg-black border-b border-green-900/50 h-20">
                <div class="text-[10px] opacity-50 mb-1">TARGET_SEQUENCE</div>
                <div id="target-sequence" class="flex gap-2 text-xl font-bold">
                    <!-- <span class="bg-green-900/30 px-2 py-1">BD</span> -->
                </div>
            </div>

            <!-- BUFFER (Your inputs) -->
            <div class="p-2 flex gap-2 items-center justify-center h-12 bg-[#050505]">
                <span class="text-[10px] opacity-50">BUFFER:</span>
                <div id="buffer-display" class="flex gap-1 text-sm text-white">
                    <!-- <span class="text-green-500">BD</span> -->
                </div>
            </div>

            <!-- THE MATRIX (Grid) -->
            <div class="flex-1 p-4 flex items-center justify-center bg-black relative overflow-hidden">
                <!-- Scanline decoration -->
                <div class="absolute top-0 left-0 w-full h-1 bg-[var(--neon-green)] opacity-20 animate-[scan_2s_linear_infinite] pointer-events-none"></div>
                
                <div id="hex-grid" class="grid grid-cols-6 gap-2 p-2 border border-green-900 bg-[#000500]">
                    <!-- Cells injected by JS -->
                </div>
            </div>
            
        </div>

        <!-- 5. OVERLAYS (Round End / Game Over) -->
        <div id="view-overlay" class="absolute inset-0 z-[60] bg-black/95 flex flex-col items-center justify-center hidden">
            <div class="border-2 border-[var(--neon-green)] p-8 min-w-[300px] text-center relative overflow-hidden">
                <div class="absolute inset-0 bg-[var(--neon-green)] opacity-5 pointer-events-none"></div>
                
                <h2 id="overlay-title" class="text-5xl mb-2 glow font-bold">BREACH_SUCCESS</h2>
                <p id="overlay-sub" class="text-sm opacity-80 mb-8">DATA_PACKET_UPLOADED</p>
                
                <div id="overlay-scores" class="flex justify-center gap-8 text-2xl mb-8">
                    <div class="text-[var(--neon-green)]">YOU: <span id="os-me">0</span></div>
                    <div class="text-[var(--neon-red)]">RIVAL: <span id="os-them">0</span></div>
                </div>

                <div id="overlay-timer" class="text-xs animate-pulse">INITIALIZING_NEXT_NODE...</div>
                <button id="btn-quit" class="hidden mt-4 border border-red-800 text-red-500 px-6 py-2 text-sm hover:bg-red-900/20">DISCONNECT</button>
            </div>
        </div>

    </div>

    <!-- LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, updateDoc, onSnapshot, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
          apiKey: "AIzaSyDCrKQVcGBW4iy7OMAtn4Jcf1ot5CGALBE",
          authDomain: "highnoon-66ee0.firebaseapp.com",
          databaseURL: "https://highnoon-66ee0-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "highnoon-66ee0",
          storageBucket: "highnoon-66ee0.firebasestorage.app",
          messagingSenderId: "754268761672",
          appId: "1:754268761672:web:7fbf59d2c403b43356727d"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const GAMES_COLLECTION = "cyber_breach_race"; 

        // --- STATE ---
        let currentUser = null;
        let currentUserName = '';
        let currentGameId = null;
        let gameUnsubscribe = null;
        let myRole = null; 
        let gameState = 'login';
        
        // Game Logic State
        let grid = []; // 2D array or 1D array with logic
        let gridSize = 6;
        let targetSequence = [];
        let playerBuffer = [];
        let activeAxis = 'row'; // 'row' or 'col'
        let activeIndex = 0; // Which row/col index is active
        let isLocked = false;

        // --- DOM ---
        const ui = {
            views: {
                login: document.getElementById('view-login'),
                lobby: document.getElementById('view-lobby'),
                waiting: document.getElementById('view-waiting'),
                game: document.getElementById('view-game'),
                overlay: document.getElementById('view-overlay')
            },
            grid: document.getElementById('hex-grid'),
            targetSeq: document.getElementById('target-sequence'),
            buffer: document.getElementById('buffer-display'),
            hud: {
                round: document.getElementById('hud-round'),
                status: document.getElementById('game-status-msg'),
                myScore: document.getElementById('hud-my-score'),
                enemyScore: document.getElementById('hud-enemy-score')
            },
            overlay: {
                title: document.getElementById('overlay-title'),
                sub: document.getElementById('overlay-sub'),
                timer: document.getElementById('overlay-timer'),
                quitBtn: document.getElementById('btn-quit'),
                scoreMe: document.getElementById('os-me'),
                scoreThem: document.getElementById('os-them')
            }
        };

        // --- AUDIO SYNTHESIS ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const playSound = (type) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if(type === 'hover') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0.02, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start();
                osc.stop(now + 0.05);
            } else if (type === 'select') {
                // Digital blip
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.setValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'error') {
                // Low buzz
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start();
                osc.stop(now + 0.3);
            } else if (type === 'success') {
                // High success chime
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.setValueAtTime(1760, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start();
                osc.stop(now + 0.4);
            }
        };

        // --- AUTH ---
        signInAnonymously(auth).catch(console.error);
        onAuthStateChanged(auth, (user) => {
            if(user) {
                currentUser = user;
                document.getElementById('auth-status').innerText = "UPLINK_ESTABLISHED";
                document.getElementById('lobby-id').innerText = `ID: ${user.uid.slice(0,6)}`;
                if(currentUserName) {
                    switchView('lobby');
                    refreshLobby();
                }
            }
        });

        document.getElementById('btn-enter').addEventListener('click', () => {
            const name = document.getElementById('username-input').value.trim().toUpperCase();
            if(!name) return;
            currentUserName = name;
            document.getElementById('lobby-user').innerText = name;
            playSound('select');
            switchView('lobby');
            refreshLobby();
        });

        // --- NAVIGATION ---
        function switchView(name) {
            Object.values(ui.views).forEach(v => v.classList.add('hidden'));
            ui.views[name].classList.remove('hidden');
            gameState = name;
        }

        // --- LOBBY ---
        document.getElementById('btn-refresh').addEventListener('click', () => { playSound('select'); refreshLobby(); });
        document.getElementById('btn-create').addEventListener('click', createGame);
        document.getElementById('btn-cancel').addEventListener('click', leaveGame);
        document.getElementById('btn-quit').addEventListener('click', leaveGame);

        async function refreshLobby() {
            const list = document.getElementById('game-list');
            list.innerHTML = '<div class="text-xs animate-pulse">SCANNING_NETWORK...</div>';
            try {
                const q = collection(db, GAMES_COLLECTION);
                const snap = await getDocs(q);
                list.innerHTML = '';
                let found = false;
                snap.forEach(d => {
                    const data = d.data();
                    if(data.status === 'waiting') {
                        found = true;
                        const div = document.createElement('div');
                        div.className = 'border border-green-900 p-2 flex justify-between items-center hover:bg-green-900/20 cursor-pointer';
                        div.innerHTML = `
                            <div><div class="font-bold text-sm">${data.hostName}</div><div class="text-[10px] opacity-50">OPEN_PORT</div></div>
                            <div class="text-xs bg-green-900 text-black px-2 py-1">JACK_IN</div>
                        `;
                        div.onclick = () => joinGame(d.id);
                        list.appendChild(div);
                    }
                });
                if(!found) list.innerHTML = '<div class="text-xs opacity-50 p-2">NO_NODES_DETECTED</div>';
            } catch(e) { console.error(e); }
        }

        // --- GAME CREATION / JOINING ---
        async function createGame() {
            playSound('select');
            if(!currentUser) return;
            const ref = doc(collection(db, GAMES_COLLECTION));
            const gameData = {
                host: currentUser.uid,
                hostName: currentUserName,
                status: 'waiting',
                createdAt: Date.now(),
                round: 1,
                hostScore: 0,
                joinerScore: 0,
                // Puzzle data will be generated per round
            };
            await setDoc(ref, gameData);
            currentGameId = ref.id;
            myRole = 'host';
            document.getElementById('waiting-code').innerText = ref.id.slice(0, 6);
            switchView('waiting');
            subscribe(currentGameId);
        }

        async function joinGame(id) {
            playSound('select');
            await updateDoc(doc(db, GAMES_COLLECTION, id), {
                joiner: currentUser.uid,
                joinerName: currentUserName,
                status: 'ready'
            });
            currentGameId = id;
            myRole = 'joiner';
            subscribe(id);
        }

        function subscribe(id) {
            if(gameUnsubscribe) gameUnsubscribe();
            gameUnsubscribe = onSnapshot(doc(db, GAMES_COLLECTION, id), (snap) => {
                if(!snap.exists()) { leaveGame(); return; }
                handleGameUpdate(snap.data());
            });
        }

        // --- GAME LOGIC & PUZZLE GENERATION ---
        
        // Hex Codes for flavor
        const CODES = ['BD', '1C', '55', '7A', 'E9', 'FF'];

        function generatePuzzle() {
            // 1. Create Grid
            const newGrid = [];
            for(let i=0; i<gridSize*gridSize; i++) {
                newGrid.push(CODES[Math.floor(Math.random() * CODES.length)]);
            }
            
            // 2. Generate a Valid Path (Length 4 or 5)
            // Start at Row 0, any column
            let path = [];
            let r = 0;
            let c = Math.floor(Math.random() * gridSize);
            
            // Force the grid to have this starting value
            newGrid[c] = CODES[Math.floor(Math.random() * CODES.length)];
            path.push(newGrid[c]); // First code is just picked, usually implicitly

            // Logic: Move Horizontal -> Vertical -> Horizontal
            let currentAxis = 'row'; // We start selecting from a row (changing column)
            // Wait, Breach Protocol: 
            // Pick from Row 0 (Top). Changes active Column.
            // Next pick from that Column. Changes active Row.
            
            // Let's generate a random sequence of length 4
            let seq = [];
            let simR = 0;
            let simC = Math.floor(Math.random() * gridSize); // Starting simulation point
            
            // Actually, to make it "fairly" random but solvable, we just generate a random sequence
            // and scatter it? No, Breach protocol requires a path.
            // Let's just generate a random sequence of length 4 for the race. 
            // There's a chance it's unsolvable, but in a race, players can reset or find partials.
            // BETTER: Ensure solvability by "walking" the grid.
            
            // Force valid start
            let walkR = 0;
            let walkC = Math.floor(Math.random() * gridSize);
            let sequence = [];
            
            // First item: We pick from Row 0.
            sequence.push(newGrid[walkC]); // (0, walkC)
            
            // Next: Pick from Column walkC (change Row)
            let nextR = Math.floor(Math.random() * gridSize);
            while(nextR === 0) nextR = Math.floor(Math.random() * gridSize); // Move somewhere else
            let idx = nextR * gridSize + walkC;
            sequence.push(newGrid[idx]);
            walkR = nextR;

            // Next: Pick from Row walkR (change Col)
            let nextC = Math.floor(Math.random() * gridSize);
            while(nextC === walkC) nextC = Math.floor(Math.random() * gridSize);
            idx = walkR * gridSize + nextC;
            sequence.push(newGrid[idx]);
            
            // 3 steps is good for a fast race
            return { grid: newGrid, sequence: sequence };
        }

        function handleGameUpdate(data) {
            // Lobby -> Game
            if(gameState === 'waiting' && data.status === 'ready') {
                if(myRole === 'host') startRound();
                return;
            }

            if(data.status === 'active' || data.status === 'finished') {
                if(gameState !== 'game' && gameState !== 'overlay') {
                    switchView('game');
                    // Init Round visuals
                    initRound(data);
                }
            }
            
            // Only init round if the puzzle data changed (simple check: sequence length/content)
            // We'll rely on local state `targetSequence` to know if we need to re-render
            const dataSeqStr = JSON.stringify(data.sequence);
            const localSeqStr = JSON.stringify(targetSequence);
            
            if(data.status === 'active' && dataSeqStr !== localSeqStr) {
                initRound(data);
            }

            updateHUD(data);

            if(data.status === 'finished' && gameState !== 'overlay') {
                showRoundResult(data);
            }
        }

        function updateHUD(data) {
            ui.hud.round.innerText = `R:0${data.round}`;
            
            const hostS = data.hostScore || 0;
            const joinerS = data.joinerScore || 0;
            
            const myS = myRole === 'host' ? hostS : joinerS;
            const enS = myRole === 'host' ? joinerS : hostS;
            
            const renderPips = (n) => Array(3).fill(0).map((_,i) => `<div class="w-2 h-4 ${i<n ? 'bg-[var(--neon-green)]' : 'bg-green-900/30'}"></div>`).join('');
            
            ui.hud.myScore.innerHTML = renderPips(myS);
            ui.hud.enemyScore.innerHTML = renderPips(enS);
        }

        // --- ROUND LOGIC ---
        async function startRound() {
            const puzzle = generatePuzzle();
            const gameRef = doc(db, GAMES_COLLECTION, currentGameId);
            await updateDoc(gameRef, {
                status: 'active',
                grid: puzzle.grid,
                sequence: puzzle.sequence,
                roundWinner: null
            });
        }

        function initRound(data) {
            // Reset Local State
            grid = data.grid;
            targetSequence = data.sequence;
            playerBuffer = [];
            activeAxis = 'row'; // Start Horizontal (Row 0)
            activeIndex = 0;    // Row 0
            isLocked = false;

            ui.views.overlay.classList.add('hidden');
            ui.hud.status.innerText = "BREACH_PROTOCOL_INITIATED";
            ui.hud.status.className = "text-[10px] text-[var(--neon-green)]";
            
            renderGrid();
            renderTarget();
            renderBuffer();
        }

        function renderTarget() {
            ui.targetSeq.innerHTML = targetSequence.map(code => 
                `<span class="bg-green-900/20 px-2 py-1 border border-green-900/50">${code}</span>`
            ).join('');
        }

        function renderBuffer() {
            ui.buffer.innerHTML = playerBuffer.map(code => 
                `<span class="text-white font-bold">${code}</span>`
            ).join(' ');
        }

        function renderGrid() {
            ui.grid.innerHTML = '';
            grid.forEach((code, i) => {
                const r = Math.floor(i / gridSize);
                const c = i % gridSize;
                
                const el = document.createElement('div');
                el.className = `hex-cell w-full aspect-square flex items-center justify-center border border-green-900/30 bg-[#001100] hover:bg-green-900/50 text-lg font-bold`;
                el.innerText = code;
                el.dataset.idx = i;
                el.dataset.r = r;
                el.dataset.c = c;
                
                // Highlight Active Axis logic
                if (activeAxis === 'row' && r === activeIndex) el.classList.add('active-axis');
                if (activeAxis === 'col' && c === activeIndex) el.classList.add('active-axis');

                el.onclick = () => handleCellClick(r, c, code, el);
                el.onmouseenter = () => playSound('hover');
                
                ui.grid.appendChild(el);
            });
        }

        async function handleCellClick(r, c, code, el) {
            if(isLocked) return;
            if(gameState !== 'game') return;

            // Validate Move
            let isValid = false;
            if(activeAxis === 'row' && r === activeIndex) isValid = true;
            if(activeAxis === 'col' && c === activeIndex) isValid = true;

            if(!isValid) {
                playSound('error');
                ui.hud.status.innerText = "INVALID_VECTOR";
                ui.hud.status.className = "text-[var(--neon-red)] animate-pulse";
                return;
            }

            // Execute Move
            playSound('select');
            el.classList.add('selected'); // Visual only, real logic is purely data
            el.classList.add('disabled'); // Cannot pick same cell twice usually in breach protocol

            playerBuffer.push(code);
            renderBuffer();

            // Switch Axis
            if(activeAxis === 'row') {
                activeAxis = 'col';
                activeIndex = c;
            } else {
                activeAxis = 'row';
                activeIndex = r;
            }

            // Re-render grid highlights
            renderGrid(); 

            // Check Win Condition
            // In Breach Protocol, buffer acts as a sliding window. 
            // For this Race, let's make it strict: Buffer must equal Sequence exactly.
            
            // Check if current buffer matches the start of target
            const currentDepth = playerBuffer.length;
            const targetSlice = targetSequence.slice(0, currentDepth);
            
            const isMatchSoFar = playerBuffer.every((val, index) => val === targetSlice[index]);

            if(!isMatchSoFar) {
                // Failed Sequence
                playSound('error');
                playerBuffer = []; // Hard reset on error for race pressure
                activeAxis = 'row';
                activeIndex = 0; // Reset to top
                renderBuffer();
                renderGrid(); // Reset highlights
                ui.hud.status.innerText = "BUFFER_FLUSHED_//_RESET";
                ui.hud.status.className = "text-[var(--neon-red)]";
                return;
            }

            if(playerBuffer.length === targetSequence.length) {
                // WINNER
                isLocked = true;
                playSound('success');
                // Update DB
                try {
                    await updateDoc(doc(db, GAMES_COLLECTION, currentGameId), {
                        roundWinner: currentUser.uid,
                        status: 'finished'
                    });
                } catch(e) { console.error(e); }
            }
        }

        function showRoundResult(data) {
            ui.views.overlay.classList.remove('hidden');
            ui.overlay.quitBtn.classList.add('hidden');
            ui.overlay.timer.classList.remove('hidden');
            
            const iWon = data.roundWinner === currentUser.uid;
            
            if(iWon) {
                ui.overlay.title.innerText = "ACCESS_GRANTED";
                ui.overlay.title.style.color = "var(--neon-green)";
                ui.overlay.sub.innerText = "DAEMON_UPLOAD_COMPLETE";
            } else {
                ui.overlay.title.innerText = "SYSTEM_LOCKOUT";
                ui.overlay.title.style.color = "var(--neon-red)";
                ui.overlay.sub.innerText = "RIVAL_BREACH_DETECTED";
            }

            // Calculate Next Round (Host Only)
            if(myRole === 'host') {
                setTimeout(async () => {
                    let hS = data.hostScore;
                    let jS = data.joinerScore;
                    
                    if(data.roundWinner === currentUser.uid) hS++; else jS++;

                    // Win Condition: First to 3 AND Win by 2
                    let winner = null;
                    if(hS >= 3 && (hS - jS) >= 2) winner = currentUser.uid;
                    else if(jS >= 3 && (jS - hS) >= 2) winner = data.joiner; // simplified

                    if(winner) {
                        // End Game
                        // We just stay on overlay with Quit button
                    } else {
                        // Next Round
                        await updateDoc(doc(db, GAMES_COLLECTION, currentGameId), {
                            hostScore: hS,
                            joinerScore: jS,
                            round: data.round + 1,
                            roundWinner: null,
                            status: 'active', // Trigger next
                            ...generatePuzzle() // New grid
                        });
                    }
                }, 3000);
            }

            ui.overlay.scoreMe.innerText = myRole === 'host' ? (data.hostScore + (iWon?1:0)) : (data.joinerScore + (iWon?1:0));
            ui.overlay.scoreThem.innerText = myRole === 'host' ? (data.joinerScore + (!iWon?1:0)) : (data.hostScore + (!iWon?1:0));
        }

        async function leaveGame() {
            if(gameUnsubscribe) gameUnsubscribe();
            if(currentGameId && myRole === 'host') {
                await deleteDoc(doc(db, GAMES_COLLECTION, currentGameId));
            }
            window.location.reload(); // Easiest reset
        }

    </script>
</body>
</html>
